#!/usr/bin/env ruby
# purpose: Piloto WAtch
# - get periodic status updates on various piloto things
# TODO:
# - output json if possible
require 'bundler/setup'
require 'getoptlong'
require 'lolcat'
#require 'thor'

opts = GetoptLong.new(
  ['--color', '-c', GetoptLong::NO_ARGUMENT],
  ['--delay', '-d', GetoptLong::OPTIONAL_ARGUMENT],
)

delay = false
color = false
opts.each do |opt, arg|
  case opt
    when '--color'
      color = true
    when '--delay'
      delay = arg.to_i
  end
end

dir_scripts = File.expand_path File.dirname(__FILE__)

cmds_watch = [
  %Q!ifconfig | grep mon!,
  %Q!ls -hltR #{ENV['HOME']}/gits/piloto/log | head -n 5!,
  %Q!tail -n 1 #{dir_scripts}/../log/wpa_roam.log!,
  %Q!#{dir_scripts}/parse_gps | tail -n 2!,
  %Q!ps aux | sort -nrk 3,3 | head -n 1!,
  %Q!df -h /!,
  %Q!echo "$(grep -v handshake #{dir_scripts}/../log/besside.log 2>/dev/null | tail -n 1 | tr -d '[[:space:]]') $(wc -l #{dir_scripts}/../log/besside.log | awk '{print $1;}')"!,
]
  # curl "localhost:2497?POLL=enable:true" # this hangs if no fix
  #%Q!top -n 1 | head -n 10!,

runonce = true 
until !runonce
  temp_f = File.read('/sys/class/thermal/thermal_zone0/temp').chomp.to_i / 1000 + 32
  temp_f *= (9.0 / 5.0) 
  delay ? system("clear") : nil
  opts_lolcat = {
    :freq => 0.1,
    :os => rand(256), 
    :spread => 3.0,
  }
  header = "[#{Time.now}] [#{temp_f}F] #{`uptime -p`.chomp}"
  if color
    Lol.println header, {}, opts_lolcat
  else
    puts header
  end
  cmds_watch.each do |c|
    opts_lolcat[:os] += 256 
    `#{c}`.chomp.split("\n").each do |line|
      #opts_lolcat[:os] += 1
      opts_lolcat[:os] = rand 256 
      if color
        Lol.println line, {}, opts_lolcat
      else
        puts line
      end
    end
  end
  runonce ? sleep(delay ? delay.to_i : 0) : nil 
  runonce = delay ? true : false
end
